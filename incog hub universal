-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Settings
local Settings = {
    -- Combat Settings
    Triggerbot = false,
    AimAssist = false,
    AimStrength = 0.3,
    AimStrengthEnabled = true,
    Smoothness = 5,
    AimRadius = 120,
    WallBang = false,
    WallCheck = true, -- Default to true for better accuracy
    TeamCheck = false,
    AliveCheck = false,
    ForceFieldCheck = false,
    TriggerbotKey = Enum.KeyCode.T,
    AimKey = Enum.KeyCode.Q,
    AimHold = true,
    AimPart = "Head",
    AimType = "Mouse",
    AimMode = "Normal",
    FOVCircle = false,
    FOVTransparency = 0.7,
    FOVColor = "Red",
    -- ESP Settings
    ESP = false,
    ShowNames = false,
    ShowBox = false,
    ShowHealth = false,
    ShowDistance = false,
    ShowTracers = false,
    Chams = false,
    ESPColor = "Red",
    -- Crosshair Settings
    CrosshairEnabled = false,
    CrosshairColor = "Red",
    CrosshairSize = 20,
    CrosshairThickness = 2,
    CrosshairGap = 0,
    -- Misc Settings
    Fullbright = true,
    Noclip = false,
    InfiniteJump = false,
    Rejoin = false,
    -- Player Settings
    WalkSpeed = 16,
    JumpPower = 50,
    GodMode = false,
    FlyEnabled = false,
    FlySpeed = 50,
    -- Config Settings
    AutoLoad = false,
    AutoLoadName = ""
}

-- Utilities
local function getColorFromName(colorName)
    local colors = {
        Red = Color3.fromRGB(255, 0, 0),
        Green = Color3.fromRGB(0, 255, 0),
        Blue = Color3.fromRGB(0, 0, 255),
        White = Color3.fromRGB(255, 255, 255),
        Yellow = Color3.fromRGB(255, 255, 0),
        Magenta = Color3.fromRGB(255, 0, 255),
        Cyan = Color3.fromRGB(0, 255, 255)
    }
    return colors[colorName] or colors.Red
end

local function parseValue(value)
    if typeof(value) == "string" and value:match("Enum%.") then
        local enumTypeStr, enumName = value:match("Enum%.([^%.]+)%.(.+)")
        if enumTypeStr and enumName then
            local enumType = Enum[enumTypeStr]
            if enumType then
                return enumType[enumName]
            end
        end
    end
    return value
end

local function waitForCharacter(timeout)
    timeout = timeout or 10
    local start = tick()
    while not LocalPlayer.Character and (tick() - start) < timeout do
        LocalPlayer.CharacterAdded:Wait()
    end
    local character = LocalPlayer.Character
    if not character then
        warn("[incog.lol] Failed to load character within timeout")
        return nil
    end
    return character
end

-- Target Management
local potentialTargets = {}

local function updatePotentialTargets()
    potentialTargets = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            table.insert(potentialTargets, player.Character)
        end
    end
end

-- Update targets periodically
spawn(function()
    while true do
        updatePotentialTargets()
        wait(0.5) -- Update every 0.5 seconds for better responsiveness
    end
end)

-- Connect to player and character events
Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            task.wait(0.1)
            updatePotentialTargets()
        end)
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    updatePotentialTargets()
end)

updatePotentialTargets() -- Initial update

-- ESP System
local espData = {}

local function createESP(player)
    if player == LocalPlayer then return end
    local char = player.Character
    if not char or not char:FindFirstChild("Head") or not char:FindFirstChild("HumanoidRootPart") then return end
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid then return end

    local color = getColorFromName(Settings.ESPColor)

    -- Drawing-based ESP for streamproof
    local box = Drawing.new("Square")
    box.Color = color
    box.Thickness = 1
    box.Filled = false
    box.Transparency = 1
    box.Visible = false

    local nameText = Drawing.new("Text")
    nameText.Color = color
    nameText.Size = 16
    nameText.Center = true
    nameText.Outline = true
    nameText.Font = 2
    nameText.Visible = false

    local healthText = Drawing.new("Text")
    healthText.Color = Color3.new(1, 1, 1)
    healthText.Size = 14
    healthText.Center = true
    healthText.Outline = true
    healthText.Font = 2
    healthText.Visible = false

    local distText = Drawing.new("Text")
    distText.Color = Color3.new(1, 1, 1)
    distText.Size = 14
    distText.Center = true
    distText.Outline = true
    distText.Font = 2
    distText.Visible = false

    local tracerLine = Drawing.new("Line")
    tracerLine.Color = color
    tracerLine.Thickness = 2
    tracerLine.Transparency = 1
    tracerLine.Visible = false

    espData[player] = {
        box = box,
        nameText = nameText,
        healthText = healthText,
        distText = distText,
        tracerLine = tracerLine,
        humanoid = humanoid
    }
end

local function removeESP(player)
    local data = espData[player]
    if data then
        data.box:Remove()
        data.nameText:Remove()
        data.healthText:Remove()
        data.distText:Remove()
        if data.tracerLine then
            data.tracerLine:Remove()
        end
        espData[player] = nil
    end
end

local function updateAllESP()
    local color = getColorFromName(Settings.ESPColor)
    for player, data in pairs(espData) do
        data.box.Color = color
        data.nameText.Color = color
        data.tracerLine.Color = color
        data.distText.Color = color
    end
end

local function updateESP()
    if not Settings.ESP then 
        for player, data in pairs(espData) do
            data.box.Visible = false
            data.nameText.Visible = false
            data.healthText.Visible = false
            data.distText.Visible = false
            data.tracerLine.Visible = false
        end
        return 
    end
    for player, data in pairs(espData) do
        local char = player.Character
        if not char or not data.humanoid or data.humanoid.Health <= 0 then
            data.box.Visible = false
            data.nameText.Visible = false
            data.healthText.Visible = false
            data.distText.Visible = false
            data.tracerLine.Visible = false
        else
            local rootPart = char:FindFirstChild("HumanoidRootPart")
            local head = char:FindFirstChild("Head")
            if rootPart and head and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local rootScreen, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                local headScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
                local legScreen = Camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 4, 0))
                if onScreen then
                    local boxHeight = math.clamp(math.abs(headScreen.Y - legScreen.Y), 10, 200)
                    local boxWidth = boxHeight / 2
                    data.box.Size = Vector2.new(boxWidth, boxHeight)
                    data.box.Position = Vector2.new(rootScreen.X - boxWidth / 2, rootScreen.Y - boxHeight / 2)
                    data.box.Visible = Settings.ShowBox

                    -- Name
                    local nameY = rootScreen.Y - boxHeight / 2 - 16
                    data.nameText.Position = Vector2.new(rootScreen.X, nameY)
                    data.nameText.Text = player.Name
                    data.nameText.Visible = Settings.ShowNames

                    -- Health
                    local healthPercent = data.humanoid.Health / data.humanoid.MaxHealth
                    data.healthText.Text = math.floor(data.humanoid.Health) .. "/" .. data.humanoid.MaxHealth
                    local healthY = nameY + 16
                    data.healthText.Position = Vector2.new(rootScreen.X, healthY)
                    data.healthText.Color = Color3.fromRGB(255 * (1 - healthPercent), 255 * healthPercent, 0)
                    data.healthText.Visible = Settings.ShowHealth

                    -- Distance
                    local dist = (rootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    data.distText.Text = math.floor(dist) .. " studs"
                    local distY = healthY + 16
                    data.distText.Position = Vector2.new(rootScreen.X, distY)
                    data.distText.Visible = Settings.ShowDistance

                    -- Tracer
                    local centerX, centerY = Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2
                    data.tracerLine.From = Vector2.new(centerX, centerY)
                    data.tracerLine.To = Vector2.new(rootScreen.X, rootScreen.Y)
                    data.tracerLine.Visible = Settings.ShowTracers
                else
                    data.box.Visible = false
                    data.nameText.Visible = false
                    data.healthText.Visible = false
                    data.distText.Visible = false
                    data.tracerLine.Visible = false
                end
            end
        end
    end
end

-- Initialize ESP
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            task.wait(1)
            createESP(player)
        end)
        if player.Character then
            createESP(player)
        end
    end
end
Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            task.wait(1)
            createESP(player)
        end)
    end
end)
Players.PlayerRemoving:Connect(removeESP)

-- Drawing Objects
local fovCircleDrawing = Drawing.new("Circle")
fovCircleDrawing.Visible = false
fovCircleDrawing.Radius = Settings.AimRadius
fovCircleDrawing.Color = getColorFromName(Settings.FOVColor)
fovCircleDrawing.Thickness = 2
fovCircleDrawing.NumSides = 100
fovCircleDrawing.Filled = false
fovCircleDrawing.Transparency = Settings.FOVTransparency

local crosshairHLine = Drawing.new("Line")
crosshairHLine.Visible = false
crosshairHLine.Color = getColorFromName(Settings.CrosshairColor)
crosshairHLine.Thickness = Settings.CrosshairThickness

local crosshairVLine = Drawing.new("Line")
crosshairVLine.Visible = false
crosshairVLine.Color = getColorFromName(Settings.CrosshairColor)
crosshairVLine.Thickness = Settings.CrosshairThickness

local function updateFOVCircle()
    fovCircleDrawing.Radius = Settings.AimRadius
    fovCircleDrawing.Color = getColorFromName(Settings.FOVColor)
    fovCircleDrawing.Transparency = Settings.FOVTransparency
end

local function updateCrosshair()
    local color = getColorFromName(Settings.CrosshairColor)
    crosshairHLine.Color = color
    crosshairVLine.Color = color
    crosshairHLine.Thickness = Settings.CrosshairThickness
    crosshairVLine.Thickness = Settings.CrosshairThickness
end
updateCrosshair()

-- UI System
local character = waitForCharacter()

-- Create ScreenGui with max priority for main UI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "incog hub ︳universal"
screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui", 5)
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.DisplayOrder = 2147483647  -- Max to prevent overlay
screenGui.Enabled = false

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Parent = screenGui
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
mainFrame.BorderSizePixel = 0
mainFrame.Position = UDim2.new(0.5, -300, 0.5, -200)
mainFrame.Size = UDim2.new(0, 600, 0, 400)
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Visible = false
mainFrame.ZIndex = 2147483647  -- Max ZIndex

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = mainFrame

-- Title Bar
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Parent = mainFrame
titleBar.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
titleBar.BorderSizePixel = 0
titleBar.Size = UDim2.new(1, 0, 0, 40)
titleBar.ZIndex = 2147483647

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 8)
titleCorner.Parent = titleBar

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "TitleLabel"
titleLabel.Parent = titleBar
titleLabel.BackgroundTransparency = 1
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.Size = UDim2.new(0.6, 0, 1, 0)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.Text = "incog hub ︳universal"
titleLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
titleLabel.TextSize = 18
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.ZIndex = 2147483647

local minimizeButton = Instance.new("TextButton")
minimizeButton.Name = "MinimizeButton"
minimizeButton.Parent = titleBar
minimizeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
minimizeButton.BorderSizePixel = 0
minimizeButton.Position = UDim2.new(1, -70, 0, 5)
minimizeButton.Size = UDim2.new(0, 30, 0, 30)
minimizeButton.Font = Enum.Font.Gotham
minimizeButton.Text = "–"
minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizeButton.TextSize = 18
minimizeButton.ZIndex = 2147483647

local minimizeCorner = Instance.new("UICorner")
minimizeCorner.CornerRadius = UDim.new(0, 4)
minimizeCorner.Parent = minimizeButton

minimizeButton.MouseButton1Click:Connect(function()
    screenGui.Enabled = false
    mainFrame.Visible = false
end)

local closeButton = Instance.new("TextButton")
closeButton.Name = "CloseButton"
closeButton.Parent = titleBar
closeButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
closeButton.BorderSizePixel = 0
closeButton.Position = UDim2.new(1, -35, 0, 5)
closeButton.Size = UDim2.new(0, 30, 0, 30)
closeButton.Font = Enum.Font.Gotham
closeButton.Text = "×"
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.TextSize = 18
closeButton.ZIndex = 2147483647

local closeCorner = Instance.new("UICorner")
closeCorner.CornerRadius = UDim.new(0, 4)
closeCorner.Parent = closeButton

closeButton.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- Tabs Frame
local tabsFrame = Instance.new("Frame")
tabsFrame.Name = "TabsFrame"
tabsFrame.Parent = mainFrame
tabsFrame.BackgroundTransparency = 1
tabsFrame.Position = UDim2.new(0, 0, 0, 40)
tabsFrame.Size = UDim2.new(1, 0, 0, 30)
tabsFrame.ZIndex = 2147483647

local tabsLayout = Instance.new("UIListLayout")
tabsLayout.FillDirection = Enum.FillDirection.Horizontal
tabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
tabsLayout.Padding = UDim.new(0, 2)
tabsLayout.Parent = tabsFrame

local tabNames = {"Combat", "Misc", "Config", "Player", "Visual", "Credits"}
local tabButtons = {}
local tabContents = {}

local function createTabButton(name)
    local tabButton = Instance.new("TextButton")
    tabButton.Name = name .. "Tab"
    tabButton.Parent = tabsFrame
    tabButton.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    tabButton.BorderSizePixel = 0
    tabButton.Size = UDim2.new(0, 90, 1, 0)
    tabButton.Font = Enum.Font.Gotham
    tabButton.Text = name
    tabButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    tabButton.TextSize = 14
    tabButton.ZIndex = 2147483647

    local tabCorner = Instance.new("UICorner")
    tabCorner.CornerRadius = UDim.new(0, 4)
    tabCorner.Parent = tabButton

    tabButton.MouseButton1Click:Connect(function()
        for _, btn in pairs(tabButtons) do
            btn.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
            btn.TextColor3 = Color3.fromRGB(200, 200, 200)
        end
        tabButton.BackgroundColor3 = Color3.fromRGB(0, 255, 255)
        tabButton.TextColor3 = Color3.fromRGB(0, 0, 0)
        for _, content in pairs(tabContents) do
            content.Visible = false
        end
        tabContents[name].Visible = true
    end)

    tabButtons[name] = tabButton
    return tabButton
end

local container = Instance.new("Frame")
container.Name = "Container"
container.Parent = mainFrame
container.BackgroundTransparency = 1
container.Position = UDim2.new(0, 0, 0, 70)
container.Size = UDim2.new(1, 0, 1, -70)
container.ZIndex = 2147483647

for _, name in ipairs(tabNames) do
    local tabContent = Instance.new("ScrollingFrame")
    tabContent.Name = name .. "Content"
    tabContent.Parent = container
    tabContent.BackgroundTransparency = 1
    tabContent.BorderSizePixel = 0
    tabContent.Size = UDim2.new(1, 0, 1, 0)
    tabContent.CanvasSize = UDim2.new(0, 0, 0, 0)
    tabContent.ScrollBarThickness = 4
    tabContent.ScrollBarImageColor3 = Color3.fromRGB(0, 255, 255)
    tabContent.Visible = name == "Combat"
    tabContent.ZIndex = 2147483647

    local padding = Instance.new("UIPadding")
    padding.PaddingTop = UDim.new(0, 5)
    padding.PaddingLeft = UDim.new(0, 5)
    padding.PaddingRight = UDim.new(0, 5)
    padding.PaddingBottom = UDim.new(0, 5)
    padding.Parent = tabContent

    local layout = Instance.new("UIListLayout")
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Padding = UDim.new(0, 3)
    layout.Parent = tabContent

    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        tabContent.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 10)
    end)

    tabContents[name] = tabContent
    createTabButton(name)
end

-- UI Helper Functions
local function makeToggle(parent, name, default, callback)
    local BtnFrame = Instance.new("Frame", parent)
    BtnFrame.Size = UDim2.new(1, -10, 0, 35)
    BtnFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    BtnFrame.BackgroundTransparency = 0.4
    BtnFrame.BorderSizePixel = 0
    BtnFrame.ZIndex = 12
    
    local BtnCorner = Instance.new("UICorner", BtnFrame)
    BtnCorner.CornerRadius = UDim.new(0, 10)
    
    local Btn = Instance.new("TextButton", BtnFrame)
    Btn.Name = "TextButton"
    Btn.Size = UDim2.new(1, 0, 1, 0)
    Btn.Text = name.." ["..(default and "ON" or "OFF").."]"
    Btn.TextColor3 = Color3.fromRGB(220, 220, 220)
    Btn.BackgroundTransparency = 1
    Btn.Font = Enum.Font.Gotham
    Btn.TextSize = 14
    Btn.ZIndex = 13
    
    local state = default
    Btn.MouseButton1Click:Connect(function()
        state = not state
        Btn.Text = name.." ["..(state and "ON" or "OFF").."]"
        Btn.TextColor3 = state and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(220, 220, 220)
        callback(state)
    end)
    
    callback(default)
end

local function makeNumberInput(parent, name, default, callback)
    local Frame = Instance.new("Frame", parent)
    Frame.Size = UDim2.new(1, -10, 0, 35)
    Frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    Frame.BackgroundTransparency = 0.4
    Frame.BorderSizePixel = 0
    Frame.ZIndex = 12
    
    local FrameCorner = Instance.new("UICorner", Frame)
    FrameCorner.CornerRadius = UDim.new(0, 10)
    
    local Label = Instance.new("TextLabel", Frame)
    Label.Size = UDim2.new(0.6, 0, 1, 0)
    Label.Text = name..": "..default
    Label.TextColor3 = Color3.fromRGB(220, 220, 220)
    Label.BackgroundTransparency = 1
    Label.Font = Enum.Font.Gotham
    Label.TextSize = 14
    Label.ZIndex = 13
    
    local Box = Instance.new("TextBox", Frame)
    Box.Size = UDim2.new(0.4, 0, 1, 0)
    Box.Position = UDim2.new(0.6, 0, 0, 0)
    Box.Text = tostring(default)
    Box.ClearTextOnFocus = false
    Box.TextColor3 = Color3.fromRGB(220, 220, 220)
    Box.BackgroundTransparency = 0.6
    Box.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    Box.Font = Enum.Font.Gotham
    Box.TextSize = 14
    Box.ZIndex = 13
    
    local BoxCorner = Instance.new("UICorner", Box)
    BoxCorner.CornerRadius = UDim.new(0, 8)
    
    Box.FocusLost:Connect(function()
        local num = tonumber(Box.Text)
        if num then
            Label.Text = name..": "..num
            callback(num)
        else
            Box.Text = tostring(default)
        end
    end)
    
    callback(default)
    return Box
end

local function makeTextInput(parent, name, default, callback)
    local Frame = Instance.new("Frame", parent)
    Frame.Size = UDim2.new(1, -10, 0, 35)
    Frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    Frame.BackgroundTransparency = 0.4
    Frame.BorderSizePixel = 0
    Frame.ZIndex = 12
    
    local FrameCorner = Instance.new("UICorner", Frame)
    FrameCorner.CornerRadius = UDim.new(0, 10)
    
    local Label = Instance.new("TextLabel", Frame)
    Label.Size = UDim2.new(0.6, 0, 1, 0)
    Label.Text = name..": "..default
    Label.TextColor3 = Color3.fromRGB(220, 220, 220)
    Label.BackgroundTransparency = 1
    Label.Font = Enum.Font.Gotham
    Label.TextSize = 14
    Label.ZIndex = 13
    
    local Box = Instance.new("TextBox", Frame)
    Box.Size = UDim2.new(0.4, 0, 1, 0)
    Box.Position = UDim2.new(0.6, 0, 0, 0)
    Box.Text = default
    Box.ClearTextOnFocus = false
    Box.TextColor3 = Color3.fromRGB(220, 220, 220)
    Box.BackgroundTransparency = 0.6
    Box.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    Box.Font = Enum.Font.Gotham
    Box.TextSize = 14
    Box.ZIndex = 13
    
    local BoxCorner = Instance.new("UICorner", Box)
    BoxCorner.CornerRadius = UDim.new(0, 8)
    
    Box.FocusLost:Connect(function()
        local val = Box.Text
        Label.Text = name..": "..val
        callback(val)
    end)
    
    callback(default)
    return Box
end

local function makeKeybindInput(parent, name, default, callback)
    local Frame = Instance.new("Frame", parent)
    Frame.Size = UDim2.new(1, -10, 0, 35)
    Frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    Frame.BackgroundTransparency = 0.4
    Frame.BorderSizePixel = 0
    Frame.ZIndex = 12
    
    local FrameCorner = Instance.new("UICorner", Frame)
    FrameCorner.CornerRadius = UDim.new(0, 10)
    
    local Label = Instance.new("TextLabel", Frame)
    Label.Size = UDim2.new(0.6, 0, 1, 0)
    local defaultStr = tostring(default):match("%.([^%.]+)$") or tostring(default):gsub("UserInputType.", ""):gsub("KeyCode.", ""):gsub("MouseButton(%d+)", "MB%1")
    Label.Text = name..": "..defaultStr
    Label.TextColor3 = Color3.fromRGB(220, 220, 220)
    Label.BackgroundTransparency = 1
    Label.Font = Enum.Font.Gotham
    Label.TextSize = 14
    Label.ZIndex = 13
    
    local Btn = Instance.new("TextButton", Frame)
    Btn.Name = "TextButton"
    Btn.Size = UDim2.new(0.4, 0, 1, 0)
    Btn.Position = UDim2.new(0.6, 0, 0, 0)
    Btn.Text = "Set Key"
    Btn.TextColor3 = Color3.fromRGB(220, 220, 220)
    Btn.BackgroundTransparency = 0.6
    Btn.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    Btn.Font = Enum.Font.Gotham
    Btn.TextSize = 14
    Btn.ZIndex = 13
    
    local BtnCorner = Instance.new("UICorner", Btn)
    BtnCorner.CornerRadius = UDim.new(0, 8)
    
    local waitingForInput = false
    Btn.MouseButton1Click:Connect(function()
        if waitingForInput then return end
        waitingForInput = true
        Btn.Text = "Press a key..."
        local inputConnection
        inputConnection = UserInputService.InputBegan:Connect(function(input, gp)
            if waitingForInput and not gp then
                waitingForInput = false
                inputConnection:Disconnect()
                Btn.Text = "Set Key"
                local keyName
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    keyName = input.KeyCode
                else
                    keyName = input.UserInputType
                end
                local displayStr = tostring(keyName):match("%.([^%.]+)$") or tostring(keyName):gsub("UserInputType.", ""):gsub("KeyCode.", ""):gsub("MouseButton(%d+)", "MB%1")
                Label.Text = name..": "..displayStr
                callback(keyName)
            end
        end)
    end)
    
    callback(default)
end

local function makePartSelector(parent, name, default, callback)
    local Frame = Instance.new("Frame", parent)
    Frame.Size = UDim2.new(1, -10, 0, 35)
    Frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    Frame.BackgroundTransparency = 0.4
    Frame.BorderSizePixel = 0
    Frame.ZIndex = 12
    
    local FrameCorner = Instance.new("UICorner", Frame)
    FrameCorner.CornerRadius = UDim.new(0, 10)
    
    local Label = Instance.new("TextLabel", Frame)
    Label.Size = UDim2.new(0.6, 0, 1, 0)
    Label.Text = name..": "..default
    Label.TextColor3 = Color3.fromRGB(220, 220, 220)
    Label.BackgroundTransparency = 1
    Label.Font = Enum.Font.Gotham
    Label.TextSize = 14
    Label.ZIndex = 13
    
    local Btn = Instance.new("TextButton", Frame)
    Btn.Size = UDim2.new(0.4, 0, 1, 0)
    Btn.Position = UDim2.new(0.6, 0, 0, 0)
    Btn.Text = default
    Btn.TextColor3 = Color3.fromRGB(220, 220, 220)
    Btn.BackgroundTransparency = 0.6
    Btn.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    Btn.Font = Enum.Font.Gotham
    Btn.TextSize = 14
    Btn.ZIndex = 13
    
    local BtnCorner = Instance.new("UICorner", Btn)
    BtnCorner.CornerRadius = UDim.new(0, 8)
    
    local options
    if name == "Aim Type" then
        options = {"Mouse", "Camera"}
    elseif name == "Aim Mode" then
        options = {"Normal", "Stick", "Smooth Lock", "Smooth Edge Lock"}
    elseif name == "Aim Part" then
        options = {"Head", "Torso", "HumanoidRootPart"}
    else
        options = {"Red", "Green", "Blue", "White", "Yellow", "Magenta", "Cyan"}
    end
    local current = default
    Btn.MouseButton1Click:Connect(function()
        local index = table.find(options, current) or 1
        index = (index % #options) + 1
        current = options[index]
        Btn.Text = current
        Label.Text = name..": "..current
        callback(current)
    end)
    
    callback(default)
end

local function makeSectionHeader(parent, text)
    local header = Instance.new("TextLabel", parent)
    header.Size = UDim2.new(1, 0, 0, 25)
    header.BackgroundTransparency = 1
    header.Text = text
    header.Font = Enum.Font.GothamBold
    header.TextSize = 16
    header.TextColor3 = Color3.fromRGB(170, 170, 255)
    header.TextXAlignment = Enum.TextXAlignment.Left
    header.ZIndex = 12
end

local function makeButton(parent, name, callback)
    local BtnFrame = Instance.new("Frame", parent)
    BtnFrame.Size = UDim2.new(1, -10, 0, 35)
    BtnFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    BtnFrame.BackgroundTransparency = 0.4
    BtnFrame.BorderSizePixel = 0
    BtnFrame.ZIndex = 12
    
    local BtnCorner = Instance.new("UICorner", BtnFrame)
    BtnCorner.CornerRadius = UDim.new(0, 10)
    
    local Btn = Instance.new("TextButton", BtnFrame)
    Btn.Name = "TextButton"
    Btn.Size = UDim2.new(1, 0, 1, 0)
    Btn.Text = name
    Btn.TextColor3 = Color3.fromRGB(220, 220, 220)
    Btn.BackgroundTransparency = 1
    Btn.Font = Enum.Font.Gotham
    Btn.TextSize = 14
    Btn.ZIndex = 13
    
    Btn.MouseButton1Click:Connect(callback)
end

-- UI Update Functions
local toggleMap = {
    ["Aim Hold Mode"] = "AimHold",
    ["Aim Strength"] = "AimStrengthEnabled"
}

local function updateAimUIToggle()
    -- Find and update Aim Assist toggle in Combat tab
    local combatContent = tabContents["Combat"]
    for _, child in ipairs(combatContent:GetChildren()) do
        if child:IsA("Frame") and child:FindFirstChild("TextButton") and child:FindFirstChild("TextButton").Text:find("Aim Assist") then
            local btn = child:FindFirstChild("TextButton")
            btn.Text = "Aim Assist ["..(Settings.AimAssist and "ON" or "OFF").."]"
            btn.TextColor3 = Settings.AimAssist and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(220, 220, 220)
            break
        end
    end
end

local function updateTriggerUIToggle()
    -- Find and update Triggerbot toggle in Combat tab
    local combatContent = tabContents["Combat"]
    for _, child in ipairs(combatContent:GetChildren()) do
        if child:IsA("Frame") and child:FindFirstChild("TextButton") and child:FindFirstChild("TextButton").Text:find("Triggerbot") then
            local btn = child:FindFirstChild("TextButton")
            btn.Text = "Triggerbot ["..(Settings.Triggerbot and "ON" or "OFF").."]"
            btn.TextColor3 = Settings.Triggerbot and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(220, 220, 220)
            break
        end
    end
end

local function updateAllUI()
    for tabName, content in pairs(tabContents) do
        for _, child in ipairs(content:GetChildren()) do
            if child:IsA("Frame") then
                local btn = child:FindFirstChild("TextButton")
                if btn and (btn.Text:find("%[ON%]") or btn.Text:find("%[OFF%]")) then
                    local settingName = btn.Text:match("^(.-) %[")
                    if settingName then
                        local key = toggleMap[settingName] or settingName:gsub(" ", "")
                        local state = Settings[key]
                        local newText = settingName .. " [" .. (state and "ON" or "OFF") .. "]"
                        btn.Text = newText
                        btn.TextColor3 = state and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(220, 220, 220)
                    end
                end
                local label = child:FindFirstChild("TextLabel")
                if label then
                    local settingStr = label.Text:match("^(.-): ")
                    if settingStr then
                        local key = settingStr:gsub(" ", "")
                        local val = Settings[key]
                        if val ~= nil then
                            label.Text = settingStr .. ": " .. tostring(val)
                            local selBtn = child:FindFirstChildOfClass("TextButton")
                            if selBtn and selBtn.Text ~= "Set Key" then
                                selBtn.Text = tostring(val)
                            end
                            local box = child:FindFirstChildOfClass("TextBox")
                            if box then
                                box.Text = tostring(val)
                            end
                        end
                    end
                end
                if child:FindFirstChild("TextButton") and child:FindFirstChild("TextButton").Text == "Set Key" then
                    local label = child:FindFirstChild("TextLabel")
                    if label then
                        local settingStr = label.Text:match("^(.-): ")
                        local keySetting
                        if settingStr == "Trigger Key" then
                            keySetting = "TriggerbotKey"
                        elseif settingStr == "Aim Key" then
                            keySetting = "AimKey"
                        end
                        if keySetting then
                            local key = Settings[keySetting]
                            local displayStr = tostring(key):match("%.([^%.]+)$") or tostring(key):gsub("UserInputType.", ""):gsub("KeyCode.", ""):gsub("MouseButton(%d+)", "MB%1")
                            label.Text = settingStr .. ": " .. displayStr
                        end
                    end
                end
                -- For Auto Load Name
                local label = child:FindFirstChild("TextLabel")
                if label and label.Text:find("Auto Load Name: ") then
                    local val = Settings.AutoLoadName
                    label.Text = "Auto Load Name: " .. val
                    local box = child:FindFirstChildOfClass("TextBox")
                    if box then
                        box.Text = val
                    end
                end
            end
        end
    end
    updateFOVCircle()
    updateCrosshair()
    updateAllESP()
end

-- Config System
local function applyGameSettings()
    if Settings.Fullbright then
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    else
        Lighting.Brightness = 1
        Lighting.ClockTime = 12
        Lighting.FogEnd = 100
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(64, 64, 64)
    end
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local hum = LocalPlayer.Character.Humanoid
        hum.WalkSpeed = Settings.WalkSpeed
        hum.JumpPower = Settings.JumpPower
        hum.MaxHealth = Settings.GodMode and math.huge or 100
        hum.Health = Settings.GodMode and math.huge or 100
    end
end

local function saveConfig(name)
    pcall(function() makefolder("incog_configs") end)
    local path = "incog_configs/" .. name .. ".json"
    writefile(path, HttpService:JSONEncode(Settings))
end

local function loadConfig(name)
    local path = "incog_configs/" .. name .. ".json"
    if isfile(path) then
        local success, data = pcall(HttpService.JSONDecode, HttpService, readfile(path))
        if success then
            for k, v in pairs(data) do
                if Settings[k] ~= nil then
                    Settings[k] = parseValue(v)
                end
            end
            updateAllUI()
            applyGameSettings()
            updateAimConnections()
            updateTriggerConnection()
        end
    end
end

-- Keybind System
local previousAimState = false
local aimBeganConn, aimEndedConn
local function updateAimConnections()
    if aimBeganConn then aimBeganConn:Disconnect() end
    if aimEndedConn then aimEndedConn:Disconnect() end
    aimBeganConn = UserInputService.InputBegan:Connect(function(input, gp)
        if not gp and typeof(Settings.AimKey) == "EnumItem" then
            local matches = false
            if Settings.AimKey.EnumType == Enum.KeyCode and input.KeyCode == Settings.AimKey then
                matches = true
            elseif Settings.AimKey.EnumType == Enum.UserInputType and input.UserInputType == Settings.AimKey then
                matches = true
            end
            if matches then
                if Settings.AimHold then
                    previousAimState = Settings.AimAssist
                    Settings.AimAssist = true
                    updateAimUIToggle()
                else
                    Settings.AimAssist = not Settings.AimAssist
                    updateAimUIToggle()
                end
            end
        end
    end)
    aimEndedConn = UserInputService.InputEnded:Connect(function(input, gp)
        if not gp and typeof(Settings.AimKey) == "EnumItem" then
            local matches = false
            if Settings.AimKey.EnumType == Enum.KeyCode and input.KeyCode == Settings.AimKey then
                matches = true
            elseif Settings.AimKey.EnumType == Enum.UserInputType and input.UserInputType == Settings.AimKey then
                matches = true
            end
            if matches and Settings.AimHold then
                Settings.AimAssist = previousAimState
                updateAimUIToggle()
            end
        end
    end)
end

local triggerConn
local function updateTriggerConnection()
    if triggerConn then triggerConn:Disconnect() end
    triggerConn = UserInputService.InputBegan:Connect(function(input, gp)
        if not gp and typeof(Settings.TriggerbotKey) == "EnumItem" then
            local matches = false
            if Settings.TriggerbotKey.EnumType == Enum.KeyCode and input.KeyCode == Settings.TriggerbotKey then
                matches = true
            elseif Settings.TriggerbotKey.EnumType == Enum.UserInputType and input.UserInputType == Settings.TriggerbotKey then
                matches = true
            end
            if matches then
                Settings.Triggerbot = not Settings.Triggerbot
                updateTriggerUIToggle()
            end
        end
    end)
end

-- Tab Population
-- Combat Tab
local combatContent = tabContents["Combat"]
makeSectionHeader(combatContent, "Triggerbot")
makeToggle(combatContent, "Triggerbot", false, function(state)
    Settings.Triggerbot = state
    updateTriggerUIToggle()
end)
local triggerKeyInput = makeKeybindInput(combatContent, "Trigger Key", Enum.KeyCode.T, function(key)
    Settings.TriggerbotKey = key
    updateTriggerConnection()
end)

makeSectionHeader(combatContent, "Aim Assist")
makeToggle(combatContent, "Aim Assist", false, function(state)
    Settings.AimAssist = state
    updateAimUIToggle()
end)
makePartSelector(combatContent, "Aim Mode", "Normal", function(mode)
    Settings.AimMode = mode
end)
makeToggle(combatContent, "Aim Strength", true, function(state)
    Settings.AimStrengthEnabled = state
end)
makeNumberInput(combatContent, "Aim Strength", 0.3, function(val)
    Settings.AimStrength = val
end)
makeNumberInput(combatContent, "Smoothness", 5, function(val)
    Settings.Smoothness = val
end)
makeToggle(combatContent, "FOV Circle", false, function(state)
    Settings.FOVCircle = state
end)
makeNumberInput(combatContent, "FOV Transparency", 0.7, function(val)
    Settings.FOVTransparency = val
    updateFOVCircle()
end)
makePartSelector(combatContent, "FOV Color", "Red", function(color)
    Settings.FOVColor = color
    updateFOVCircle()
end)
makeToggle(combatContent, "Aim Hold Mode", true, function(state)
    Settings.AimHold = state
end)
makeNumberInput(combatContent, "Aim Radius", 120, function(val)
    Settings.AimRadius = val
    updateFOVCircle()
end)
makePartSelector(combatContent, "Aim Part", "Head", function(part)
    Settings.AimPart = part
end)
makePartSelector(combatContent, "Aim Type", "Mouse", function(type)
    Settings.AimType = type
end)
local aimKeyInput = makeKeybindInput(combatContent, "Aim Key", Enum.KeyCode.Q, function(key)
    Settings.AimKey = key
    updateAimConnections()
end)

makeSectionHeader(combatContent, "Checks")
makeToggle(combatContent, "Wall Bang", false, function(state)
    Settings.WallBang = state
end)
makeToggle(combatContent, "Wall Check", true, function(state) -- Default true
    Settings.WallCheck = state
end)
makeToggle(combatContent, "Team Check", false, function(state)
    Settings.TeamCheck = state
end)
makeToggle(combatContent, "Alive Check", false, function(state)
    Settings.AliveCheck = state
end)
makeToggle(combatContent, "ForceField Check", false, function(state)
    Settings.ForceFieldCheck = state
end)

-- Visual Tab
local visualContent = tabContents["Visual"]
makeSectionHeader(visualContent, "ESP")
makeToggle(visualContent, "Enable ESP", false, function(state)
    Settings.ESP = state
end)
makeToggle(visualContent, "Names", false, function(state)
    Settings.ShowNames = state
end)
makeToggle(visualContent, "Box", false, function(state)
    Settings.ShowBox = state
end)
makeToggle(visualContent, "Health", false, function(state)
    Settings.ShowHealth = state
end)
makeToggle(visualContent, "Distance", false, function(state)
    Settings.ShowDistance = state
end)
makeToggle(visualContent, "Tracers", false, function(state)
    Settings.ShowTracers = state
end)
makeToggle(visualContent, "Chams", false, function(state)
    Settings.Chams = state
    -- Note: Chams not implemented for streamproof
end)
makePartSelector(visualContent, "ESP Color", "Red", function(color)
    Settings.ESPColor = color
    updateAllESP()
end)

makeSectionHeader(visualContent, "Other Visuals")
makeToggle(visualContent, "Crosshair", false, function(state)
    Settings.CrosshairEnabled = state
end)
makePartSelector(visualContent, "Crosshair Color", "Red", function(color)
    Settings.CrosshairColor = color
    updateCrosshair()
end)
makeNumberInput(visualContent, "Crosshair Size", 20, function(val)
    Settings.CrosshairSize = val
end)
makeNumberInput(visualContent, "Crosshair Thickness", 2, function(val)
    Settings.CrosshairThickness = val
    updateCrosshair()
end)
makeNumberInput(visualContent, "Crosshair Gap", 0, function(val)
    Settings.CrosshairGap = val
end)

-- Misc Tab
local miscContent = tabContents["Misc"]
makeSectionHeader(miscContent, "Misc Features")
makeToggle(miscContent, "Fullbright", true, function(state)
    Settings.Fullbright = state
    if state then
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    else
        Lighting.Brightness = 1
        Lighting.ClockTime = 12
        Lighting.FogEnd = 100
        Lighting.GlobalShadows = true
        Lighting.OutdoorAmbient = Color3.fromRGB(64, 64, 64)
    end
end)
makeToggle(miscContent, "Noclip", false, function(state)
    Settings.Noclip = state
end)
makeToggle(miscContent, "Infinite Jump", false, function(state)
    Settings.InfiniteJump = state
end)

makeSectionHeader(miscContent, "Actions")
makeButton(miscContent, "Rejoin Server", function()
    game:GetService("TeleportService"):Teleport(game.PlaceId, LocalPlayer)
end)

-- Config Tab
local configContent = tabContents["Config"]
makeSectionHeader(configContent, "Auto Load")
makeToggle(configContent, "Auto Load", false, function(state)
    Settings.AutoLoad = state
end)
makeTextInput(configContent, "Auto Load Name", "", function(val)
    Settings.AutoLoadName = val
end)

makeSectionHeader(configContent, "Config Manager")
local configNameBox = makeTextInput(configContent, "Config Name", "", function(val) end)

makeButton(configContent, "Save Config", function()
    local name = configNameBox.Text
    if name ~= "" then
        saveConfig(name)
    end
end)

makeButton(configContent, "Load Config", function()
    local name = configNameBox.Text
    if name ~= "" then
        loadConfig(name)
    end
end)

makeButton(configContent, "Delete Config", function()
    local name = configNameBox.Text
    if name ~= "" then
        local path = "incog_configs/" .. name .. ".json"
        if isfile(path) then
            delfile(path)
        end
    end
end)

-- Player Tab
local playerContent = tabContents["Player"]
makeSectionHeader(playerContent, "Player Mods")
makeNumberInput(playerContent, "Walk Speed", 16, function(val)
    Settings.WalkSpeed = val
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.WalkSpeed = val
    end
end)
makeNumberInput(playerContent, "Jump Power", 50, function(val)
    Settings.JumpPower = val
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.JumpPower = val
    end
end)
makeToggle(playerContent, "God Mode", false, function(state)
    Settings.GodMode = state
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        LocalPlayer.Character.Humanoid.MaxHealth = state and math.huge or 100
        LocalPlayer.Character.Humanoid.Health = state and math.huge or 100
    end
end)
makeToggle(playerContent, "Fly", false, function(state)
    Settings.FlyEnabled = state
end)
makeNumberInput(playerContent, "Fly Speed", 50, function(val)
    Settings.FlySpeed = val
end)

-- Credits Tab
local creditsContent = tabContents["Credits"]
local creditsLabel = Instance.new("TextLabel")
creditsLabel.Parent = creditsContent
creditsLabel.BackgroundTransparency = 1
creditsLabel.Size = UDim2.new(1, 0, 1, 0)
creditsLabel.Text = "made by coolybean & incog"
creditsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
creditsLabel.TextSize = 24
creditsLabel.Font = Enum.Font.GothamBold
creditsLabel.TextXAlignment = Enum.TextXAlignment.Center
creditsLabel.TextYAlignment = Enum.TextYAlignment.Center
creditsLabel.ZIndex = 2147483647

-- UI Toggle
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Insert then
        local wasEnabled = screenGui.Enabled
        screenGui.Enabled = not screenGui.Enabled
        mainFrame.Visible = screenGui.Enabled
        mainFrame.Active = screenGui.Enabled
    end
end)

-- Initial UI Setup
tabButtons["Combat"].BackgroundColor3 = Color3.fromRGB(0, 255, 255)
tabButtons["Combat"].TextColor3 = Color3.fromRGB(0, 0, 0)
updateAimConnections()
updateTriggerConnection()

-- Feature Implementations
-- Infinite Jump
local infJumpConnection
infJumpConnection = UserInputService.JumpRequest:Connect(function()
    if Settings.InfiniteJump and LocalPlayer.Character then
        LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
    end
end)

-- Noclip
spawn(function()
    while true do
        if Settings.Noclip and LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
        wait(0.1)
    end
end)

-- Fly
local flyConnection
local bodyVelocity, bodyAngularVelocity
flyConnection = RunService.Heartbeat:Connect(function()
    if Settings.FlyEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = LocalPlayer.Character.HumanoidRootPart
        if not bodyVelocity then
            bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
            bodyVelocity.Parent = rootPart
        end
        if not bodyAngularVelocity then
            bodyAngularVelocity = Instance.new("BodyAngularVelocity")
            bodyAngularVelocity.MaxTorque = Vector3.new(4000, 4000, 4000)
            bodyAngularVelocity.AngularVelocity = Vector3.new(0, 0, 0)
            bodyAngularVelocity.Parent = rootPart
        end
        local moveVector = LocalPlayer.Character.Humanoid.MoveDirection * Settings.FlySpeed
        bodyVelocity.Velocity = Vector3.new(moveVector.X, 0, moveVector.Z)
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            bodyVelocity.Velocity = bodyVelocity.Velocity + Vector3.new(0, Settings.FlySpeed, 0)
        elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            bodyVelocity.Velocity = bodyVelocity.Velocity - Vector3.new(0, Settings.FlySpeed, 0)
        end
    elseif bodyVelocity then
        bodyVelocity:Destroy()
        bodyAngularVelocity:Destroy()
        bodyVelocity = nil
        bodyAngularVelocity = nil
    end
end)

-- Update player stats on respawn
LocalPlayer.CharacterAdded:Connect(function(newChar)
    newChar:WaitForChild("Humanoid")
    newChar.Humanoid.WalkSpeed = Settings.WalkSpeed
    newChar.Humanoid.JumpPower = Settings.JumpPower
    if Settings.GodMode then
        newChar.Humanoid.MaxHealth = math.huge
        newChar.Humanoid.Health = math.huge
    end
end)

-- Targeting System
local function getTargetPartName(model, part)
    if part == "Head" then
        return "Head"
    elseif part == "HumanoidRootPart" then
        return "HumanoidRootPart"
    elseif part == "Torso" then
        return model:FindFirstChild("Torso") and "Torso" or "UpperTorso"
    end
    return "Head" -- fallback
end

-- Visibility check using raycast
local function isVisible(targetPart, targetModel)
    if not Settings.WallCheck then return true end
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, direction, raycastParams)
    return result == nil or result.Instance:IsDescendantOf(targetModel)
end

-- Valid target check
local function isValidTarget(character)
    if character == LocalPlayer.Character then return false end
    local player = Players:GetPlayerFromCharacter(character)
    if player and Settings.TeamCheck and player.Team == LocalPlayer.Team then return false end
    local hum = character:FindFirstChild("Humanoid")
    if not hum or not hum.Parent then return false end
    if Settings.AliveCheck and (hum.Health <= 0 or hum.Health == 0) then return false end
    if Settings.ForceFieldCheck and character:FindFirstChild("ForceField") then return false end
    return true
end

-- Prediction data
local lastPositions = {}
local lastTimes = {}

-- Get closest to crosshair (using predicted position without vertical velocity)
local function getClosestToCursor()
    local closest, dist = nil, Settings.AimRadius
    local mousePos = UserInputService:GetMouseLocation()
    local now = tick()
    for _, obj in ipairs(potentialTargets) do
        if isValidTarget(obj) then
            local part = Settings.AimPart
            local targetPartName = getTargetPartName(obj, part)
            local targetPart = obj:FindFirstChild(targetPartName)
            if targetPart and isVisible(targetPart, obj) then
                local currentPos = targetPart.Position
                local key = obj
                local predictedPos = currentPos
                if lastPositions[key] then
                    local dt = now - lastTimes[key]
                    if dt > 0 then
                        local vel = (currentPos - lastPositions[key]) / dt
                        local predictTime = 0.1
                        predictedPos = currentPos + Vector3.new(vel.X, 0, vel.Z) * predictTime
                    end
                end
                lastPositions[key] = currentPos
                lastTimes[key] = now

                local pos, onScreen = Camera:WorldToViewportPoint(predictedPos)
                if onScreen then
                    local mag = (Vector2.new(pos.X,pos.Y) - mousePos).Magnitude
                    if mag < dist then
                        dist = mag
                        closest = obj
                    end
                end
            end
        end
    end
    return closest
end

-- Raycast for triggerbot
local function getRaycastTarget()
    if Settings.WallBang then
        -- Wallbang: check if crosshair is over enemy part, ignoring walls
        local closest, dist = nil, math.huge
        local mousePos = UserInputService:GetMouseLocation()
        for _, obj in ipairs(potentialTargets) do
            if isValidTarget(obj) then
                local part = Settings.AimPart
                local targetPartName = getTargetPartName(obj, part)
                local targetPart = obj:FindFirstChild(targetPartName)
                if targetPart then
                    local pos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                    if onScreen then
                        local screenPos = Vector2.new(pos.X, pos.Y)
                        local mag = (screenPos - mousePos).Magnitude
                        if mag < 5 and mag < dist then  -- Small radius for crosshair precision
                            dist = mag
                            closest = obj
                        end
                    end
                end
            end
        end
        return closest
    else
        -- Normal raycast for clear line of sight
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local result = workspace:Raycast(Camera.CFrame.Position, Camera.CFrame.LookVector * 1000, rayParams)
        if result and result.Instance then
            local char = result.Instance.Parent
            if char:FindFirstChild("Humanoid") and isValidTarget(char) then
                return char
            end
        end
        return nil
    end
end

-- Controller detection
local function isControllerInputDown()
    return UserInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
end

-- Main Loop Variables
local triggerState = false
local wasMouseDown = false

-- Main Loop
RunService.RenderStepped:Connect(function()
    updateESP()

    -- Streamproof FOV
    if Settings.FOVCircle then
        local mousePos = UserInputService:GetMouseLocation()
        fovCircleDrawing.Position = mousePos
        fovCircleDrawing.Radius = Settings.AimRadius
        fovCircleDrawing.Color = getColorFromName(Settings.FOVColor)
        fovCircleDrawing.Transparency = Settings.FOVTransparency
        fovCircleDrawing.Visible = true
    else
        fovCircleDrawing.Visible = false
    end

    -- Streamproof Crosshair
    if Settings.CrosshairEnabled then
        local centerX, centerY = Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2
        local effectiveSize = math.max(0, Settings.CrosshairSize - Settings.CrosshairGap)
        crosshairHLine.From = Vector2.new(centerX - effectiveSize / 2, centerY)
        crosshairHLine.To = Vector2.new(centerX + effectiveSize / 2, centerY)
        crosshairHLine.Color = getColorFromName(Settings.CrosshairColor)
        crosshairHLine.Thickness = Settings.CrosshairThickness
        crosshairHLine.Visible = true

        crosshairVLine.From = Vector2.new(centerX, centerY - effectiveSize / 2)
        crosshairVLine.To = Vector2.new(centerX, centerY + effectiveSize / 2)
        crosshairVLine.Color = getColorFromName(Settings.CrosshairColor)
        crosshairVLine.Thickness = Settings.CrosshairThickness
        crosshairVLine.Visible = true
    else
        crosshairHLine.Visible = false
        crosshairVLine.Visible = false
    end

    -- Triggerbot logic with hold state
    local target = getRaycastTarget()
    local inputTrigger = Settings.Triggerbot or isControllerInputDown()
    local shouldTrigger = inputTrigger and target ~= nil
    if shouldTrigger and not triggerState then
        triggerState = true
        pcall(function()
            mouse1press()
        end)
    elseif not shouldTrigger and triggerState then
        triggerState = false
        pcall(function()
            mouse1release()
        end)
    end

    wasMouseDown = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)

    if Settings.AimAssist then
        local newTarget = getClosestToCursor()
        if newTarget then
            local part = Settings.AimPart
            local targetPartName = getTargetPartName(newTarget, part)
            local targetPart = newTarget:FindFirstChild(targetPartName)
            if targetPart then  -- Visibility already checked in getClosestToCursor
                local currentPos = targetPart.Position
                local now = tick()
                local key = newTarget
                if not lastPositions[key] then
                    lastPositions[key] = currentPos
                    lastTimes[key] = now
                end
                local dt = now - lastTimes[key]
                local vel = (dt > 0) and (currentPos - lastPositions[key]) / dt or Vector3.new(0, 0, 0)
                local predictTime = 0.1  -- Increased for better tracking
                local predictedPos = currentPos + Vector3.new(vel.X, 0, vel.Z) * predictTime
                lastPositions[key] = currentPos
                lastTimes[key] = now

                local pos, onScreen = Camera:WorldToViewportPoint(predictedPos)
                if onScreen then
                    local baseStrength = Settings.AimStrengthEnabled and Settings.AimStrength or 1
                    local strength
                    if Settings.AimMode == "Normal" then
                        strength = baseStrength
                    elseif Settings.AimMode == "Stick" then
                        strength = 1
                    elseif Settings.AimMode == "Smooth Lock" then
                        strength = baseStrength / Settings.Smoothness
                    elseif Settings.AimMode == "Smooth Edge Lock" then
                        strength = 1 / Settings.Smoothness
                    else
                        strength = baseStrength
                    end
                    if Settings.AimType == "Mouse" then
                        local mousePos = UserInputService:GetMouseLocation()
                        local dx = (pos.X - mousePos.X)
                        local dy = (pos.Y - mousePos.Y)
                        dx = dx * strength
                        dy = dy * strength
                        -- Increased clamp for smoother lock-on
                        local maxMove = 50
                        dx = math.clamp(dx, -maxMove, maxMove)
                        dy = math.clamp(dy, -maxMove, maxMove)
                        pcall(function()
                            mousemoverel(dx, dy)
                        end)
                    else
                        -- Camera aim
                        local targetCFrame = CFrame.lookAt(Camera.CFrame.Position, predictedPos)
                        Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, strength)
                    end
                end
            end
        else
            -- Clean up stale prediction data if no target
            for k in pairs(lastPositions) do
                lastPositions[k] = nil
                lastTimes[k] = nil
            end
        end
    end
end)

-- Initialization
applyGameSettings()

-- Auto load config if enabled
if Settings.AutoLoad and Settings.AutoLoadName ~= "" then
    loadConfig(Settings.AutoLoadName)
end
